Our work is based on several foundations, which we will discuss in the sections below.

\subsection{Microservice Architecture}
\label{sec:Foundation:MicroserviceArchitecture}
In a microservice architecture, the software is partitioned into many small components (``microservices''), which operate independently of each other and communicate via messages \cite{Dragoni2017}.
This software architecture style allows the construction of highly reusable components which focus on a single task (e.g. applying a watermark to a video).
This loose coupling allows for independent teams to work on different components or even the use of off-the-shelf components.
Also, scaling the application can be achieved by simply duplicating the bottlenecked microservices \cite{Dragoni2017}.
A microservice is defined by its provided- and required-interfaces, which allow for the message-exchange with other components \cite{Singh2021}.

\subsection{Asynchronous Communication}
\label{sec:Foundation:AsyncCommunication}
\todo{Einleitungs-Satz}
\todo{Bild}


\subsubsection{Asynchronous RESTful Communication}
\label{sec:Foundation:AsyncCommunication:REST}
%\begin{figure}
%\centering
%\begin{tikzpicture}[node distance=2.5cm,auto,>=latex']
%  % Define nodes
%  \node (client) [rectangle,draw] {Client};
%  \node (microservice1) [rectangle,draw,right of=client] {Microservice 1};
%  \node (microservice2) [rectangle,draw,right of=microservice1] {Microservice 2};
%  \node (202response) [rectangle,draw,below of=microservice1,yshift=-1cm] {202 Response};
%  \node (failedresponse) [rectangle,draw,below of=microservice2,yshift=-1cm] {Failed Response};
%  \node (successfulresponse) [rectangle,draw,below of=microservice2,yshift=-1cm] {Successful Response};
%  \node (fitbox) [draw,dashed,fit=(202response) (failedresponse) (successfulresponse)] {};
%  
%  % Draw edges
%  \path[->] (client) edge node[above] {initial request} (microservice1);
%  \path[->] (microservice1) edge (202response);
%  \path[->] (client) edge[bend left] node[above] {attempt to get results} (microservice2);
%  \path[->] (microservice2) edge (failedresponse);
%  \path[->] (client) edge[bend left] node[above] {attempt to get results} (microservice2);
%  \path[->] (microservice2) edge (successfulresponse);
%  \path[->] (successfulresponse) edge[out=225,in=135] (client);
%%  \draw[->,decorate,decoration={markings,mark=at position 0.5 with {\arrow[scale=1.5]{>}}},postaction={decorate}] (fitbox.north west) -- (client.west);
%\end{tikzpicture}
%\caption{Asynchronous Communication using HTTP REST}
%\label{fig:ImageAsyncHTTP}
%\end{figure}

Microservices that communicate asynchronously are typically realized in one of two kinds.
Either using a RESTful pattern or using message-based communication. \\

Some systems use microservices that communicate asynchronously via asynchronous HTTP REST interfaces.
There are two interaction scenarios for this kind of asynchronous communication.
One possibility is that the initial HTTP request returns an HTTP code 202 (Accepted) and provides a location where the microservice can query the status of the operation.
Once the operation on the server has finished, the provided location will return the results of the query. \cite{Mayer2018}

Alternatively, the microservice may be required to provide a callback method (e.g. a web hook, \cite{Webhooks}) where the server can send the results once the operation has finished \cite{Mayer2018}. \\

We will refer to both of these communication methods as RESTful asynchronous communication in the following paper.


\subsubsection{Message-based Communication}
\label{sec:Foundation:AsyncCommunication:MBC}

\begin{figure}
\centering
\begin{tikzpicture}[node distance=2.5cm]
  % Define nodes
  \node (microservice1) [rectangle,draw] {Microservice 1};
  \node (microservice2) [rectangle,draw,below of=microservice1] {Microservice 2};
  \node (messagebroker) [rectangle,draw,right of=microservice2,xshift=4cm] {Message Broker};
  \node (microservice3) [rectangle,draw,below of=microservice2] {Microservice 3};

  % Draw edges
  \draw [->] (microservice1) -- node[pos=.5, above, sloped] (TextNode) {send message} (messagebroker);
  \draw [->] (microservice2) -- node[pos=.5, above, sloped] (TextNode) {consume message} (messagebroker);
  \draw [->] (microservice3) -- node[pos=.5, above, sloped] (TextNode) {consume message} (messagebroker);
\end{tikzpicture}
\caption{Asynchronous Communication using a message broker}
\label{fig:ImageAsyncMBC}
\end{figure}

Contrary to RESTful asynchronous communication, other microservice systems use message-based asynchronous communication.
These systems use messages or events to facilitate communication between its microservices.
These messages or events are typically sent using a messaging system (e.g., Java Message Service, JMS \footnote{https://www.oracle.com/technical-resources/articles/java/intro-java-message-service.html}) or a message broker (e.g., Apache Kafka \footnote{https://github.com/berndruecker/Dowing-retail/tree/master/kafka/java} or RabbitMQ \footnote{https://www.rabbitmq.com}).
These messaging systems or brokers provide a reliable, scalable and decoupled way for the microservices to communicate with each other.
Using a message broker also allows for better system performance \cite{Singh2021}.


\subsection{Reverse Engineering}
\label{sec:Foundation:SAR}
Reverse engineering is a Software Architecture Extraction (SAR) technique that uses the artifacts of the system (e.g., source code, logs) to analyze the system.
Vital for building the architecture of the software-system is information about the communication between the different components.
This information is extracted using either a static (using only static inputs, e.g. source code), dynamic (using runtime information, e.g. logs) or hybrid (using both) approach.
In the context of asynchronous communication, a static extraction algorithm would in the case of a RESTful asynchronous communication, analyze the HTTP calls made in code to determine the relationships between the components.
In the case of message-based communication, a static approach is unable to extract a useful architecture, since message-based systems exchange those messages only at runtime and thus the required information about which components communicate with each other can only be retrieved as part of a dynamic or hybrid analysis. \cite{Singh2021,Mayer2018}


\subsection{Palladio Component Model}
\label{sec:Foundation:PCM}
%CG
The Palladio Component Model (PCM) is a meta-model for the description of component-based software \cite{Becker2008}.
It is used to predict the performance properties of component-based software at design-time by specifying a model of the system, its components and how the system is going to be used.
A PCM consists of four main views that represent the aspects of the system.
The Component View represents the functional structure of the system, i.e. the components, their interfaces and, the dependencies between them.
The Resource View represents the resources (e.g., CPU, memory, databases, libraries) required by the system.
The Allocation View shows, which components are allocated to which resources.
Finally, the Repository View represents the data structures and operations provided by the system's components as well as the relationships between them. \cite{Becker2008}
