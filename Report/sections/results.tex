\autoref{table:results} shows the results of the comparison in tabular format.
In the following sections, we will talk about each paper individually.

Each approach will be presented using five aspects:
\begin{enumerate}
	\item \textbf{Input} (e.g. source code or logs)
	\item \textbf{Approach} (how the extraction process works)
	\item \textbf{Output} (e.g. PCM or UML)
	\item \textbf{End user} (who the result is intended for)
	\item \textbf{Evaluation} (how were the results evaluated)
\end{enumerate}

\subsection{ARCHI4MOM}
\label{sec:Results:ARCHI4MOM}
\textbf{Input.}
The ARCHI4MOM approach extends the Performance Model Extraction (PMX) approach \cite{Walter2017PMX,Singh2022ARCHI4MOM} and therefore takes the same inputs.
The first step in the ARCHI4MOM approach is to instrument the source code with the Jaeger tracing tool \footnote{https://www.jaegertracing.io/} to collect tracing data.
Using the OpenTracing API, ARCHI4MOM then instruments all microservices to generate trace data, which can be used later to reconstruct the asynchronous communication between the microservices. \cite{Singh2022ARCHI4MOM} % TODO: Also supports MOM
\\ \\
\textbf{Approach.}
ARCHI4MOM extends the Performance Model Extraction (PMX) approach \cite{Walter2017PMX,Singh2022ARCHI4MOM} to support asynchronous communication.
This is achieved by adding a dependency to the OpenTracing API to each microservice to introduce a new set of information that was not present earlier \cite{Singh2022ARCHI4MOM}.
This tracing data is then collected in the form of JavaScript Object Notation (JSON) files, which become the input of the next phase \cite{Singh2022ARCHI4MOM}.

The JSON files will then be used to analyze the structure of the traces.
For message-based asynchronous communication, this presents a challenge since the information is distributed over different \textit{spans} whereas using synchronous communication, it would be in a single span \cite{Singh2022ARCHI4MOM}.
To match this inter-component communication using middleware, the called method needs to be matched using the OpenTracing API tags \cite{Singh2022ARCHI4MOM}.
In the next step, the ARCHI4MOM approach looks for send operations that do not have information about the topic \todo{explain} they send to and fills in this information by retrieving it from other send operations in the tracing data \cite{Singh2022ARCHI4MOM}.
Then the approach iterates over all sending spans that have a FOLLOWS-FROM or \textit{message-bus} relation \todo{explain} tag and propagate their topics to the receiving spans \cite{Singh2022ARCHI4MOM}.

To reconstruct message-based communication using PMX, the authors extended PMX to support the required Palladio Component Model elements \footnote{https://github.com/PalladioSimulator/Palladio-Addons-Indirections/tree/maste r/bundles/org.palladiosimulator.indirections/model}.
The authors then implement additional PMX logic to be able to reconstruct asynchronous architectures using these model elements.
\cite{Singh2022ARCHI4MOM}.
\\ \\
\textbf{Output.}
The output of the ARCHI4MOM approach is a Palladio Component Model (PCM) \cite{Singh2022ARCHI4MOM}.
This PCM contains the extracted components, as well as the interfaces for communication between each other \cite{Singh2022ARCHI4MOM}.
The communication channels are represented by \textit{DataChannel}s (representing the middleware) and \textit{DataInterface}s (representing the type of data the interface can send/receive), which are created in the PCM repository as part of the extraction \cite{Singh2022ARCHI4MOM}.
\\ \\
\textbf{End User.}
The output of the ARCHI4MOM approach is a PCM.
This model can then be used by software architects together with usage scenarios to create simulations, predicting the non-functional properties of the software.
\\ \\
\textbf{Evaluation.}
To evaluate the approach, the authors created a manual PCM of the Flowing Retail sample application \footnote{https://github.com/berndruecker/flowing-retail/tree/master/kafka/java}.
This manual model was then verified by three developers to be correct and compared to the automatically extracted model using a Goal Question Metric (GQM) plan \cite{VanSolingen2002GQM,Singh2022ARCHI4MOM}.
Using this plan, both sets of model elements (manual and automatic) are then compared using Precision, Recall and F1 score \cite{Singh2022ARCHI4MOM}.
The automatic approach achieved a precision score of 100\%, a recall score of 95.65\% and an F1 score of 97.8\% \cite{Singh2022ARCHI4MOM}.

\subsection{MiSAR}
\label{sec:Results:MiSAR}
\textbf{Input.}
MiSAR extracts and gathers different data from static artifacts.
This data includes docker files that assemble the containers for the microservices, docker compose files that orchestrate multi-docker-container systems, java source code, maven pom.xml files, YAML configuration files, documentation and tool support \cite{Alshuqayran2018MiSAR}.
The java source code is reverse engineered using a tool called Enterprise architect \footnote{http://www.sparxsystems.com.au/products/ea/}, providing UML class diagrams from the source code \cite{Alshuqayran2018MiSAR}.
Additionally, Zipkin \footnote{https://zipkin.io} is used to trace communication between microservices to build a call graph \cite{Alshuqayran2018MiSAR}.
Information about latencies was retrieved using TCPDump \footnote{https://www.tcpdump.org} and information about the ports, IP addresses of container, and connectivity between containers were extracted using the Sysdig tool \footnote{https://github.com/draios/sysdig} \cite{Alshuqayran2018MiSAR}.
This information is all stored in a repository for further use.
\\ \\
\textbf{Approach.}
% TODO: Explain MDE, PIM, PSM; approach transforms from PSM to PIM using mapping rules
MiSAR is a manual approach that is executed in two phases \cite{Alshuqayran2018MiSAR}.
The first phase (Recovery Design, RD) defines architectural concepts, which are extracted in the second phase (Recovery Execution, RE) \cite{Alshuqayran2018MiSAR}.


% TODO: Answer RQ!



% TODO: Table has to be in horizontal orientation
% TODO: Header should be bold
% TODO: Line breaks in cells
% TODO: table too wide

\begin{sidewaystable}
\centering
% check that total width matches
\begin{tabular}{| p{2.5cm} | p{2cm} | p{4cm} | p{2cm} | p{2cm} | p{4cm} | p{1cm} | p{1.2cm} |}
\toprule
\textbf{Name} & \textbf{Input} & \textbf{Approach} & \textbf{Output} & \textbf{End User} & \textbf{Evaluation} & \textbf{Year} & \textbf{Type} \\
\midrule
ARCHI4MOM (\cite{Singh2022ARCHI4MOM})
& source code
& Extend PMX to support asynchronous architectures
& PCM
& software architect
& Comparison with manual architecture
& 2022
& tool \\
\midrule
MiSAR (\cite{Alshuqayran2018MiSAR})
& source code, descriptive files, runtime traces
& manual extraction approach \todo{extend}
& 
& 
& 
& 2018
& manual approach \\
\midrule
--- (\cite{Brosig2011})
& run-time monitoring data
& combine an existing call path tracing and resource demand estimation to an end-to-end model extraction
& performance model \todo{which?}
& 
& SPECjEnterprise2010 benchmark application; comparison of prediction with measurements
& 2011
& tool \\
\midrule
MICROLYZE (\cite{Kleehaus2018}) 
& monitoring data
& continuously monitor for system changes using a service discovery service; trace HTTP requests using zipkin
& database with services and their relations; web application to visualize as adjacency matrix
& system administrators and enterprise or software architects
& approach was applied to TUM LLCM platform, Travelcompanion service; traffic was generated and result was manually checked
& 2018
& tool \\
\midrule
--- (\cite{Mayer2018}) 
& static service information, infrastructure information and runtime logs
& condense static and dynamic information into single dimension to analyze the evolution over time; visualize information in dashboard
& aggregated data, visualized in dashboard
& 
& use tool in testing environment; check viability of results
& 2018
& tool \\
\bottomrule
\end{tabular}
\caption{Results} % TODO: Explanation text
\label{table:results}
\end{sidewaystable}
